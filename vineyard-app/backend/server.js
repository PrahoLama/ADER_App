const express = require('express');
const multer = require('multer');
const cors = require('cors');
const path = require('path');
const fs = require('fs');
const { spawn } = require('child_process');
const FormData = require('form-data');
const axios = require('axios');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 5000;

// Enhanced logging middleware
app.use((req, res, next) => {
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.url}`);
  next();
});

// CORS configuration
app.use(cors({
  origin: '*',
  credentials: true,
  methods: ['GET', 'POST', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));

app.use(express.json());

// Create uploads directory
const uploadDir = path.join(__dirname, 'uploads');
if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir, { recursive: true });
  console.log('‚úÖ Created uploads directory:', uploadDir);
}

// Configure multer
const storage = multer.diskStorage({
  destination: (req, file, cb) => cb(null, uploadDir),
  filename: (req, file, cb) => {
    const filename = Date.now() + path.extname(file.originalname);
    cb(null, filename);
  }
});

const upload = multer({
  storage,
  limits: { fileSize: 500 * 1024 * 1024 }
});

// Health check
app.get('/api/health', (req, res) => {
  console.log('‚úÖ Health check received');
  res.json({ status: 'Backend running', timestamp: new Date() });
});

// ==================== ENHANCED DJI LOG PARSER WITH DEEP DEBUGGING ====================

// ==================== DJI LOG PARSER WITH dji-log BINARY ====================

app.post('/api/parse-dji-log', upload.single('logFile'), async (req, res) => {
  console.log('\n' + '='.repeat(60));
  console.log('üöÅ DJI LOG PARSING REQUEST - USING dji-log BINARY');
  console.log('='.repeat(60));

  const djiLogBinary = path.join(__dirname, 'dji-log'); // Path to dji-log binary
  let logFilePath = null;
  let csvOutputPath = null;

  try {
    if (!req.file) {
      return res.status(400).json({ error: 'No log file uploaded' });
    }

    logFilePath = path.join(uploadDir, req.file.filename);
    csvOutputPath = path.join(uploadDir, `flight_data_${Date.now()}.csv`);

    console.log('üìÑ Log file:', logFilePath);
    console.log('üì¶ File size:', req.file.size, 'bytes');
    console.log('üìù Output CSV:', csvOutputPath);

    // Check if dji-log binary exists
    if (!fs.existsSync(djiLogBinary)) {
      throw new Error('dji-log binary not found. Please download it from https://github.com/lvauvillier/dji-log-parser/releases');
    }

    // ============================================================
    // STEP 1: Run dji-log command to convert TXT to CSV
    // ============================================================
    console.log('\nüîß Running dji-log command...');

    const apiKey = process.env.DJI_API_KEY || '6a1613c4a95bea88c227b4b760e528e';

    await new Promise((resolve, reject) => {
      const djiLogProcess = spawn(djiLogBinary, [
        '--api-key', apiKey,
        logFilePath,
        '--csv', csvOutputPath
      ]);

      let stdout = '';
      let stderr = '';

      djiLogProcess.stdout.on('data', (data) => {
        stdout += data.toString();
        console.log('dji-log stdout:', data.toString());
      });

      djiLogProcess.stderr.on('data', (data) => {
        stderr += data.toString();
        console.error('dji-log stderr:', data.toString());
      });

      djiLogProcess.on('close', (code) => {
        console.log('dji-log process exited with code:', code);

        if (code !== 0) {
          reject(new Error(`dji-log failed with code ${code}: ${stderr}`));
        } else {
          console.log('‚úÖ CSV file generated successfully');
          resolve();
        }
      });

      djiLogProcess.on('error', (error) => {
        reject(new Error(`Failed to run dji-log: ${error.message}`));
      });
    });

    // ============================================================
    // STEP 2: Parse the generated CSV file
    // ============================================================
    console.log('\nüìä Parsing generated CSV file...');

    if (!fs.existsSync(csvOutputPath)) {
      throw new Error('CSV file was not generated by dji-log');
    }

    const csvContent = fs.readFileSync(csvOutputPath, 'utf8');
    const lines = csvContent.split('\n').filter(line => line.trim());

    console.log(`üìã Total lines in CSV: ${lines.length}`);

    if (lines.length < 2) {
      throw new Error('CSV file is empty or invalid');
    }

    // Parse CSV header
    const header = lines[0].split(',').map(h => h.trim().replace(/^"|"$/g, ''));
    console.log(`üìã CSV Headers (${header.length} columns):`, header.slice(0, 10));

    // Find key column indices
    const keyColumns = {
      datetime: header.findIndex(h => h.toLowerCase().includes('datetime') || h.toLowerCase().includes('time')),
      latitude: header.findIndex(h => h.toLowerCase().includes('latitude') || h === 'OSD.latitude'),
      longitude: header.findIndex(h => h.toLowerCase().includes('longitude') || h === 'OSD.longitude'),
      altitude: header.findIndex(h => h.toLowerCase().includes('altitude') || h === 'OSD.altitude'),
      height: header.findIndex(h => h.toLowerCase().includes('height') || h === 'OSD.height'),
      speed: header.findIndex(h => h.toLowerCase().includes('speed')),
      battery: header.findIndex(h => h.toLowerCase().includes('battery') && h.toLowerCase().includes('level')),
    };

    console.log('üîç Key column indices:', keyColumns);

    // Parse data rows
    const parsedData = [];
    for (let i = 1; i < lines.length; i++) {
      const line = lines[i];
      if (!line.trim()) continue;

      // Enhanced CSV parsing (handles quoted values)
      const values = [];
      let current = '';
      let inQuotes = false;

      for (let j = 0; j < line.length; j++) {
        const char = line[j];
        if (char === '"') {
          inQuotes = !inQuotes;
        } else if (char === ',' && !inQuotes) {
          values.push(current.trim().replace(/^"|"$/g, ''));
          current = '';
        } else {
          current += char;
        }
      }
      values.push(current.trim().replace(/^"|"$/g, ''));

      // Build row object
      const row = {};
      for (let idx = 0; idx < Math.min(values.length, header.length); idx++) {
        let value = values[idx];
        // Try to parse as number
        if (value && value !== '' && !isNaN(value)) {
          value = parseFloat(value);
        }
        row[header[idx]] = value;
      }

      // Only add rows with valid GPS data
      const lat = keyColumns.latitude >= 0 ? row[header[keyColumns.latitude]] : null;
      const lon = keyColumns.longitude >= 0 ? row[header[keyColumns.longitude]] : null;

      if (lat && lon && !isNaN(lat) && !isNaN(lon)) {
        parsedData.push(row);
      }
    }

    console.log(`‚úÖ Parsed ${parsedData.length} valid GPS records`);

    if (parsedData.length === 0) {
      throw new Error('No valid GPS data found in the log file');
    }

    // ============================================================
    // STEP 3: Extract flight information for dashboard
    // ============================================================
    console.log('\nüìä Extracting flight information...');

    const flightPath = parsedData.map(record => {
      const datetime = keyColumns.datetime >= 0 ? record[header[keyColumns.datetime]] : null;
      const latitude = keyColumns.latitude >= 0 ? parseFloat(record[header[keyColumns.latitude]]) : null;
      const longitude = keyColumns.longitude >= 0 ? parseFloat(record[header[keyColumns.longitude]]) : null;
      const altitude = keyColumns.altitude >= 0 ? parseFloat(record[header[keyColumns.altitude]]) || 0 : 0;
      const height = keyColumns.height >= 0 ? parseFloat(record[header[keyColumns.height]]) || 0 : 0;

      return {
        timestamp: datetime,
        latitude: latitude,
        longitude: longitude,
        altitude: altitude,
        relativeAltitude: height,
      };
    }).filter(point => point.latitude && point.longitude);

    // Calculate statistics
    let maxAltitude = 0;
    let maxSpeed = 0;
    let totalDistance = 0;
    let maxBattery = 0;
    let minBattery = 100;

    for (let i = 0; i < parsedData.length; i++) {
      const record = parsedData[i];

      // Altitude
      const altitude = keyColumns.altitude >= 0 ? parseFloat(record[header[keyColumns.altitude]]) || 0 : 0;
      if (altitude > maxAltitude) maxAltitude = altitude;

      // Speed
      const speed = keyColumns.speed >= 0 ? parseFloat(record[header[keyColumns.speed]]) || 0 : 0;
      if (speed > maxSpeed) maxSpeed = speed;

      // Battery
      const battery = keyColumns.battery >= 0 ? parseFloat(record[header[keyColumns.battery]]) || 0 : 0;
      if (battery > maxBattery) maxBattery = battery;
      if (battery < minBattery && battery > 0) minBattery = battery;

      // Distance between consecutive points
      if (i > 0) {
        const lat = keyColumns.latitude >= 0 ? parseFloat(record[header[keyColumns.latitude]]) : null;
        const lon = keyColumns.longitude >= 0 ? parseFloat(record[header[keyColumns.longitude]]) : null;
        const prevLat = keyColumns.latitude >= 0 ? parseFloat(parsedData[i - 1][header[keyColumns.latitude]]) : null;
        const prevLon = keyColumns.longitude >= 0 ? parseFloat(parsedData[i - 1][header[keyColumns.longitude]]) : null;

        if (lat && lon && prevLat && prevLon) {
          totalDistance += calculateDistance(prevLat, prevLon, lat, lon);
        }
      }
    }

    // Calculate duration
    const startTime = keyColumns.datetime >= 0 ? parsedData[0][header[keyColumns.datetime]] : null;
    const endTime = keyColumns.datetime >= 0 ? parsedData[parsedData.length - 1][header[keyColumns.datetime]] : null;
    let duration = 'Unknown';

    if (startTime && endTime) {
      try {
        const start = new Date(startTime);
        const end = new Date(endTime);
        const durationMs = end - start;

        const hours = Math.floor(durationMs / 3600000);
        const minutes = Math.floor((durationMs % 3600000) / 60000);
        const seconds = Math.floor((durationMs % 60000) / 1000);

        if (hours > 0) duration = `${hours}h ${minutes}m ${seconds}s`;
        else if (minutes > 0) duration = `${minutes}m ${seconds}s`;
        else duration = `${seconds}s`;
      } catch (e) {
        console.error('Duration calculation error:', e);
      }
    }

    const flightInfo = {
      fileName: req.file.originalname,
      fileSize: req.file.size,
      parsedAt: new Date().toISOString(),
      parsingMethod: 'dji-log-binary',

      summary: {
        totalRecords: parsedData.length,
        duration: duration,
        startTime: startTime,
        endTime: endTime,
      },

      flightPath: flightPath,

      statistics: {
        maxAltitude: Math.round(maxAltitude * 100) / 100,
        maxSpeed: Math.round(maxSpeed * 100) / 100,
        totalDistance: Math.round(totalDistance * 100) / 100,
        avgSpeed: parsedData.length > 0 ? Math.round((totalDistance / (parsedData.length * 0.2)) * 100) / 100 : 0,
        batteryStart: maxBattery,
        batteryEnd: minBattery,
      },

      rawDataSample: parsedData.slice(0, 100),
      hasMoreData: parsedData.length > 100,
    };

    console.log('\nüìä FLIGHT SUMMARY:');
    console.log('  Records:', flightInfo.summary.totalRecords);
    console.log('  Duration:', flightInfo.summary.duration);
    console.log('  GPS points:', flightInfo.flightPath.length);
    console.log('  Max altitude:', flightInfo.statistics.maxAltitude, 'm');
    console.log('  Max speed:', flightInfo.statistics.maxSpeed, 'm/s');
    console.log('  Total distance:', flightInfo.statistics.totalDistance, 'm');

    // ============================================================
    // STEP 4: Cleanup temporary files
    // ============================================================
    console.log('\nüßπ Cleaning up temporary files...');
    try {
      if (logFilePath && fs.existsSync(logFilePath)) {
        fs.unlinkSync(logFilePath);
        console.log('‚úÖ Deleted log file');
      }
      if (csvOutputPath && fs.existsSync(csvOutputPath)) {
        fs.unlinkSync(csvOutputPath);
        console.log('‚úÖ Deleted CSV file');
      }
    } catch (cleanupErr) {
      console.error('‚ö†Ô∏è Cleanup error:', cleanupErr.message);
    }

    // ============================================================
    // STEP 5: Return results to frontend
    // ============================================================
    res.json({
      success: true,
      data: flightInfo
    });

  } catch (error) {
    console.error('\n' + '='.repeat(60));
    console.error('‚ùå FATAL ERROR');
    console.error('='.repeat(60));
    console.error('Error:', error.message);
    console.error('Stack:', error.stack);

    // Cleanup on error
    try {
      if (logFilePath && fs.existsSync(logFilePath)) {
        fs.unlinkSync(logFilePath);
      }
      if (csvOutputPath && fs.existsSync(csvOutputPath)) {
        fs.unlinkSync(csvOutputPath);
      }
    } catch (cleanupErr) {
      console.error('Cleanup error:', cleanupErr.message);
    }

    res.status(500).json({
      error: 'Failed to parse DJI log file',
      details: error.message,
      hint: 'Make sure dji-log binary is in the backend folder'
    });
  }
});

// Helper function to calculate distance between GPS coordinates
function calculateDistance(lat1, lon1, lat2, lon2) {
  const R = 6371e3; // Earth's radius in meters
  const œÜ1 = lat1 * Math.PI / 180;
  const œÜ2 = lat2 * Math.PI / 180;
  const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
  const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

  const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
    Math.cos(œÜ1) * Math.cos(œÜ2) *
    Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

  return R * c; // Distance in meters
}
// ==================== HELPER FUNCTIONS ====================

// ==================== IMAGE ANNOTATION ENDPOINT ====================

app.post('/api/annotate-images', upload.fields([
  { name: 'logFile', maxCount: 1 },
  { name: 'images', maxCount: 100 }
]), async (req, res) => {
  console.log('\n' + '='.repeat(60));
  console.log('üì∏ IMAGE ANNOTATION REQUEST');
  console.log('='.repeat(60));

  const djiLogBinary = path.join(__dirname, 'dji-log');
  let logFilePath = null;
  let csvOutputPath = null;
  const uploadedImagePaths = [];

  try {
    if (!req.files?.logFile || !req.files?.images) {
      return res.status(400).json({ 
        error: 'Both log file and images are required' 
      });
    }

    logFilePath = path.join(uploadDir, req.files.logFile[0].filename);
    csvOutputPath = path.join(uploadDir, `flight_data_${Date.now()}.csv`);

    console.log('üìÑ Log file:', logFilePath);
    console.log('üì∏ Images count:', req.files.images.length);

    // Store image paths
    req.files.images.forEach(img => {
      uploadedImagePaths.push({
        path: path.join(uploadDir, img.filename),
        originalName: img.originalname,
        filename: img.filename
      });
    });

    // Check if dji-log binary exists
    if (!fs.existsSync(djiLogBinary)) {
      throw new Error('dji-log binary not found');
    }

    // ============================================================
    // STEP 1: Run dji-log to generate CSV with ALL columns
    // ============================================================
    console.log('\nüîß Running dji-log command...');

    const apiKey = process.env.DJI_API_KEY || '6a1613c4a95bea88c227b4b760e528e';

    await new Promise((resolve, reject) => {
      const djiLogProcess = spawn(djiLogBinary, [
        '--api-key', apiKey,
        logFilePath,
        '--csv', csvOutputPath
      ]);

      let stderr = '';

      djiLogProcess.stderr.on('data', (data) => {
        stderr += data.toString();
      });

      djiLogProcess.on('close', (code) => {
        if (code !== 0) {
          reject(new Error(`dji-log failed: ${stderr}`));
        } else {
          resolve();
        }
      });

      djiLogProcess.on('error', (error) => {
        reject(new Error(`Failed to run dji-log: ${error.message}`));
      });
    });

    // ============================================================
    // STEP 2: Parse CSV and extract ALL flight parameters
    // ============================================================
    console.log('\nüìä Parsing CSV for all flight parameters...');

    const csvContent = fs.readFileSync(csvOutputPath, 'utf8');
    const lines = csvContent.split('\n').filter(line => line.trim());

    if (lines.length < 2) {
      throw new Error('CSV file is empty');
    }

    // Parse header
    const header = lines[0].split(',').map(h => h.trim().replace(/^"|"$/g, ''));
    console.log(`üìã Found ${header.length} columns in CSV`);

    // Find ALL relevant column indices
    const columnIndices = {
      datetime: findColumnIndex(header, ['datetime', 'time', 'OSD.flyTime']),
      latitude: findColumnIndex(header, ['OSD.latitude', 'latitude']),
      longitude: findColumnIndex(header, ['OSD.longitude', 'longitude']),
      altitude: findColumnIndex(header, ['OSD.altitude', 'altitude']),
      height: findColumnIndex(header, ['OSD.height', 'height', 'OSD.relativeHeight']),
      pitch: findColumnIndex(header, ['OSD.pitch', 'pitch']),
      roll: findColumnIndex(header, ['OSD.roll', 'roll']),
      yaw: findColumnIndex(header, ['OSD.yaw', 'yaw']),
      xSpeed: findColumnIndex(header, ['OSD.xSpeed', 'xSpeed', 'OSD.vpsNorthSpeed']),
      ySpeed: findColumnIndex(header, ['OSD.ySpeed', 'ySpeed', 'OSD.vpsEastSpeed']),
      zSpeed: findColumnIndex(header, ['OSD.zSpeed', 'zSpeed', 'OSD.vpsGroundSpeed']),
      hSpeed: findColumnIndex(header, ['OSD.hSpeed', 'hSpeed', 'horizontalSpeed']),
      gimbalPitch: findColumnIndex(header, ['GIMBAL.pitch', 'gimbal.pitch']),
      gimbalRoll: findColumnIndex(header, ['GIMBAL.roll', 'gimbal.roll']),
      gimbalYaw: findColumnIndex(header, ['GIMBAL.yaw', 'gimbal.yaw']),
      batteryLevel: findColumnIndex(header, ['BATTERY.level', 'battery.level', 'OSD.batteryLevel']),
      batteryVoltage: findColumnIndex(header, ['BATTERY.voltage', 'battery.voltage']),
      gpsNum: findColumnIndex(header, ['OSD.gpsNum', 'gpsNum', 'GPS.numSatellites']),
      flightMode: findColumnIndex(header, ['OSD.flycState', 'flightMode']),
    };

    console.log('üîç Column indices found:', columnIndices);

    // Parse all data rows
    const flightData = [];
    for (let i = 1; i < lines.length; i++) {
      const values = parseCSVLine(lines[i]);
      if (values.length === 0) continue;

      const record = {};
      header.forEach((col, idx) => {
        let value = values[idx];
        if (value && value !== '' && !isNaN(value)) {
          value = parseFloat(value);
        }
        record[col] = value;
      });

      // Only add if has valid GPS
      const lat = getValueByIndex(record, header, columnIndices.latitude);
      const lon = getValueByIndex(record, header, columnIndices.longitude);

      if (isValidCoordinate(lat, lon)) {
        flightData.push({
          timestamp: getValueByIndex(record, header, columnIndices.datetime),
          latitude: lat,
          longitude: lon,
          altitude: getValueByIndex(record, header, columnIndices.altitude) || 0,
          height: getValueByIndex(record, header, columnIndices.height) || 0,
          pitch: getValueByIndex(record, header, columnIndices.pitch) || 0,
          roll: getValueByIndex(record, header, columnIndices.roll) || 0,
          yaw: getValueByIndex(record, header, columnIndices.yaw) || 0,
          xSpeed: getValueByIndex(record, header, columnIndices.xSpeed) || 0,
          ySpeed: getValueByIndex(record, header, columnIndices.ySpeed) || 0,
          zSpeed: getValueByIndex(record, header, columnIndices.zSpeed) || 0,
          hSpeed: getValueByIndex(record, header, columnIndices.hSpeed) || 0,
          gimbalPitch: getValueByIndex(record, header, columnIndices.gimbalPitch) || 0,
          gimbalRoll: getValueByIndex(record, header, columnIndices.gimbalRoll) || 0,
          gimbalYaw: getValueByIndex(record, header, columnIndices.gimbalYaw) || 0,
          batteryLevel: getValueByIndex(record, header, columnIndices.batteryLevel) || 0,
          gpsNum: getValueByIndex(record, header, columnIndices.gpsNum) || 0,
          flightMode: getValueByIndex(record, header, columnIndices.flightMode) || 'Unknown',
          rawRecord: record
        });
      }
    }

    console.log(`‚úÖ Parsed ${flightData.length} flight records with full parameters`);

    // ============================================================
    // STEP 3: Match images with flight data by timestamp
    // ============================================================
    console.log('\nüîó Matching images with flight data...');

    const annotatedImages = [];

    for (const imgInfo of uploadedImagePaths) {
      const imageAnnotation = {
        imageName: imgInfo.originalName,
        matchMethod: 'none',
        flightData: null
      };

      // Try to extract timestamp from filename
      // Common patterns: IMG_20251115_164300, DJI_0001_20251115164300, etc.
      const timestampFromName = extractTimestampFromFilename(imgInfo.originalName);

      if (timestampFromName && flightData.length > 0) {
        // Find closest flight record by timestamp
        const closest = findClosestFlightRecord(flightData, timestampFromName);
        if (closest) {
          imageAnnotation.matchMethod = 'timestamp';
          imageAnnotation.flightData = closest;
          imageAnnotation.timestampDiff = closest.timeDiff;
        }
      }

      // If no timestamp match, try sequential matching (by index)
      if (!imageAnnotation.flightData && flightData.length > 0) {
        const imgIndex = uploadedImagePaths.indexOf(imgInfo);
        const dataIndex = Math.floor((imgIndex / uploadedImagePaths.length) * flightData.length);
        imageAnnotation.matchMethod = 'sequential';
        imageAnnotation.flightData = flightData[Math.min(dataIndex, flightData.length - 1)];
      }

      annotatedImages.push(imageAnnotation);
    }

    // ============================================================
    // STEP 4: Generate annotation output
    // ============================================================
    console.log('\nüìù Generating annotations...');

    const annotations = annotatedImages.map(img => {
      const fd = img.flightData || {};
      return {
        imageName: img.imageName,
        matchMethod: img.matchMethod,
        timestamp: fd.timestamp || null,
        gps: {
          latitude: round(fd.latitude, 8),
          longitude: round(fd.longitude, 8),
          altitude: round(fd.altitude, 2),
          height: round(fd.height, 2),
          satellites: fd.gpsNum || 0
        },
        orientation: {
          pitch: round(fd.pitch, 2),
          roll: round(fd.roll, 2),
          yaw: round(fd.yaw, 2)
        },
        gimbal: {
          pitch: round(fd.gimbalPitch, 2),
          roll: round(fd.gimbalRoll, 2),
          yaw: round(fd.gimbalYaw, 2)
        },
        speed: {
          horizontal: round(fd.hSpeed, 2),
          xSpeed: round(fd.xSpeed, 2),
          ySpeed: round(fd.ySpeed, 2),
          zSpeed: round(fd.zSpeed, 2)
        },
        battery: {
          level: round(fd.batteryLevel, 1)
        },
        flightMode: fd.flightMode
      };
    });

    // Generate CSV output
    const csvOutput = generateAnnotationCSV(annotations);

    // ============================================================
    // STEP 5: Cleanup
    // ============================================================
    console.log('\nüßπ Cleaning up...');
    try {
      if (logFilePath && fs.existsSync(logFilePath)) fs.unlinkSync(logFilePath);
      if (csvOutputPath && fs.existsSync(csvOutputPath)) fs.unlinkSync(csvOutputPath);
      uploadedImagePaths.forEach(img => {
        if (fs.existsSync(img.path)) fs.unlinkSync(img.path);
      });
    } catch (e) {
      console.error('Cleanup error:', e.message);
    }

    // ============================================================
    // STEP 6: Return results
    // ============================================================
    console.log('\n‚úÖ Annotation complete!');
    console.log(`   Images annotated: ${annotations.length}`);

    res.json({
      success: true,
      data: {
        totalImages: annotations.length,
        totalFlightRecords: flightData.length,
        annotations: annotations,
        csvData: csvOutput,
        flightSummary: {
          startTime: flightData[0]?.timestamp,
          endTime: flightData[flightData.length - 1]?.timestamp,
          recordCount: flightData.length
        }
      }
    });

  } catch (error) {
    console.error('‚ùå ANNOTATION ERROR:', error.message);

    // Cleanup on error
    try {
      if (logFilePath && fs.existsSync(logFilePath)) fs.unlinkSync(logFilePath);
      if (csvOutputPath && fs.existsSync(csvOutputPath)) fs.unlinkSync(csvOutputPath);
      uploadedImagePaths.forEach(img => {
        if (fs.existsSync(img.path)) fs.unlinkSync(img.path);
      });
    } catch (e) {}

    res.status(500).json({
      error: 'Failed to annotate images',
      details: error.message
    });
  }
});

// ==================== HELPER FUNCTIONS FOR ANNOTATION ====================

function findColumnIndex(header, possibleNames) {
  for (const name of possibleNames) {
    const idx = header.findIndex(h => 
      h.toLowerCase() === name.toLowerCase() || 
      h.toLowerCase().includes(name.toLowerCase())
    );
    if (idx >= 0) return idx;
  }
  return -1;
}

function getValueByIndex(record, header, index) {
  if (index < 0 || index >= header.length) return null;
  return record[header[index]];
}

function parseCSVLine(line) {
  const values = [];
  let current = '';
  let inQuotes = false;

  for (let i = 0; i < line.length; i++) {
    const char = line[i];
    if (char === '"') {
      inQuotes = !inQuotes;
    } else if (char === ',' && !inQuotes) {
      values.push(current.trim().replace(/^"|"$/g, ''));
      current = '';
    } else {
      current += char;
    }
  }
  values.push(current.trim().replace(/^"|"$/g, ''));
  return values;
}

function extractTimestampFromFilename(filename) {
  // Pattern 1: IMG_20251115_164300.jpg -> 2025-11-15T16:43:00
  let match = filename.match(/(\d{4})(\d{2})(\d{2})_?(\d{2})(\d{2})(\d{2})/);
  if (match) {
    return new Date(`${match[1]}-${match[2]}-${match[3]}T${match[4]}:${match[5]}:${match[6]}`);
  }

  // Pattern 2: DJI_0001_2025-11-15_16-43-00.jpg
  match = filename.match(/(\d{4})-(\d{2})-(\d{2})[_-](\d{2})-(\d{2})-(\d{2})/);
  if (match) {
    return new Date(`${match[1]}-${match[2]}-${match[3]}T${match[4]}:${match[5]}:${match[6]}`);
  }

  // Pattern 3: Use file modification time from EXIF (would need additional library)
  return null;
}

function findClosestFlightRecord(flightData, targetTime) {
  let closest = null;
  let minDiff = Infinity;

  for (const record of flightData) {
    if (!record.timestamp) continue;

    const recordTime = new Date(record.timestamp);
    if (isNaN(recordTime.getTime())) continue;

    const diff = Math.abs(recordTime.getTime() - targetTime.getTime());
    if (diff < minDiff) {
      minDiff = diff;
      closest = { ...record, timeDiff: diff };
    }
  }

  // Only return if within 5 minutes (300000ms)
  if (closest && minDiff < 300000) {
    return closest;
  }
  return null;
}

function round(value, decimals) {
  if (value === null || value === undefined || isNaN(value)) return 0;
  return Math.round(value * Math.pow(10, decimals)) / Math.pow(10, decimals);
}

function generateAnnotationCSV(annotations) {
  const headers = [
    'Image Name',
    'Match Method',
    'Timestamp',
    'Latitude',
    'Longitude',
    'Altitude (m)',
    'Height (m)',
    'GPS Satellites',
    'Pitch (¬∞)',
    'Roll (¬∞)',
    'Yaw (¬∞)',
    'Gimbal Pitch (¬∞)',
    'Gimbal Roll (¬∞)',
    'Gimbal Yaw (¬∞)',
    'Horizontal Speed (m/s)',
    'X Speed (m/s)',
    'Y Speed (m/s)',
    'Z Speed (m/s)',
    'Battery Level (%)',
    'Flight Mode'
  ];

  let csv = headers.join(',') + '\n';

  for (const ann of annotations) {
    const row = [
      `"${ann.imageName}"`,
      ann.matchMethod,
      ann.timestamp ? `"${ann.timestamp}"` : '',
      ann.gps.latitude,
      ann.gps.longitude,
      ann.gps.altitude,
      ann.gps.height,
      ann.gps.satellites,
      ann.orientation.pitch,
      ann.orientation.roll,
      ann.orientation.yaw,
      ann.gimbal.pitch,
      ann.gimbal.roll,
      ann.gimbal.yaw,
      ann.speed.horizontal,
      ann.speed.xSpeed,
      ann.speed.ySpeed,
      ann.speed.zSpeed,
      ann.battery.level,
      `"${ann.flightMode}"`
    ];
    csv += row.join(',') + '\n';
  }

  return csv;
}

// Enhanced DJI Binary Log Format Parser
async function parseDJIBinaryLog(fileBuffer) {
  try {
    const header = fileBuffer.slice(0, 4).toString('hex');
    console.log('üîç Binary header:', header);
    console.log('üì¶ File size:', fileBuffer.length, 'bytes');

    const records = [];

    // DJI Format Detection
    const isDJIFormat = header.startsWith('29') || header.startsWith('55') || header.startsWith('66');

    if (!isDJIFormat) {
      throw new Error(`Not a recognized DJI binary format (header: ${header})`);
    }

    console.log('‚úÖ Detected DJI binary format');

    // Parse DJI Record Structure
    console.log('üîç Parsing DJI record structure...');

    let offset = 0;
    let recordCount = 0;

    while (offset < fileBuffer.length - 100) {
      try {
        // Look for record markers (0x29 is common DJI record marker)
        if (fileBuffer[offset] === 0x29 && offset + 60 < fileBuffer.length) {

          // Read potential record header
          const recordType = fileBuffer[offset + 1];
          const recordLength = fileBuffer.readUInt16LE(offset + 2);

          // Validate record length
          if (recordLength > 0 && recordLength < 1000 && offset + recordLength < fileBuffer.length) {

            // Try to extract GPS data from various offset positions
            const gpsOffsets = [8, 12, 16, 20, 24, 28, 32, 36, 40];

            for (const gpsOffset of gpsOffsets) {
              if (offset + gpsOffset + 16 <= fileBuffer.length) {

                // Try reading as double (8 bytes each for lat/lon)
                const lat1 = readSafeDouble(fileBuffer, offset + gpsOffset);
                const lon1 = readSafeDouble(fileBuffer, offset + gpsOffset + 8);

                if (isValidCoordinate(lat1, lon1)) {
                  const altitude = readSafeFloat(fileBuffer, offset + gpsOffset + 16) || 0;

                  // Try to find timestamp
                  let timestamp = null;
                  for (let ts = offset; ts < offset + 40 && ts + 4 < fileBuffer.length; ts += 4) {
                    const possibleTime = fileBuffer.readUInt32LE(ts);
                    if (possibleTime > 1420070400 && possibleTime < 1893456000) {
                      timestamp = new Date(possibleTime * 1000).toISOString();
                      break;
                    }
                  }

                  records.push({
                    latitude: lat1,
                    longitude: lon1,
                    altitude: altitude,
                    relativeAltitude: altitude,
                    timestamp: timestamp || new Date().toISOString()
                  });

                  recordCount++;
                  break;
                }

                // Try reading as float (4 bytes each for lat/lon)
                const lat2 = readSafeFloat(fileBuffer, offset + gpsOffset);
                const lon2 = readSafeFloat(fileBuffer, offset + gpsOffset + 4);

                if (isValidCoordinate(lat2, lon2)) {
                  const altitude = readSafeFloat(fileBuffer, offset + gpsOffset + 8) || 0;

                  records.push({
                    latitude: lat2,
                    longitude: lon2,
                    altitude: altitude,
                    relativeAltitude: altitude,
                    timestamp: new Date().toISOString()
                  });

                  recordCount++;
                  break;
                }
              }
            }

            offset += recordLength;
          } else {
            offset++;
          }
        } else {
          offset++;
        }
      } catch (e) {
        offset++;
      }
    }

    // Remove duplicates
    const uniqueRecords = removeDuplicateCoordinates(records);

    console.log('üìä Total GPS points found:', uniqueRecords.length);

    if (uniqueRecords.length >= 5) {
      console.log('‚úÖ Successfully extracted GPS data from binary format');
      return uniqueRecords;
    } else {
      throw new Error(
        `Not enough valid GPS data found (found ${uniqueRecords.length} points, need at least 5).\n\n` +
        `This appears to be an encrypted or proprietary DJI format.\n\n` +
        `üìã Recommended solutions:\n` +
        `1. Install dji-log-parser-js: npm install dji-log-parser-js\n` +
        `2. Get DJI API key for v13+ encrypted logs from https://developer.dji.com/\n` +
        `3. Use DJI Flight Log Viewer (https://www.phantomhelp.com/logviewer/upload/)\n` +
        `4. Use Airdata UAV (https://app.airdata.com/) for professional parsing`
      );
    }
  } catch (error) {
    throw error;
  }
}

// Helper function to safely read doubles
function readSafeDouble(buffer, offset) {
  if (offset + 8 > buffer.length) return null;
  try {
    const value = buffer.readDoubleLE(offset);
    return (isNaN(value) || !isFinite(value)) ? null : value;
  } catch (e) {
    return null;
  }
}

// Helper function to safely read floats
function readSafeFloat(buffer, offset) {
  if (offset + 4 > buffer.length) return null;
  try {
    const value = buffer.readFloatLE(offset);
    return (isNaN(value) || !isFinite(value)) ? null : value;
  } catch (e) {
    return null;
  }
}

// Validate GPS coordinates
function isValidCoordinate(lat, lon) {
  return (
    typeof lat === 'number' &&
    typeof lon === 'number' &&
    !isNaN(lat) &&
    !isNaN(lon) &&
    isFinite(lat) &&
    isFinite(lon) &&
    lat >= -90 &&
    lat <= 90 &&
    lon >= -180 &&
    lon <= 180 &&
    (Math.abs(lat) > 0.001 || Math.abs(lon) > 0.001) // Not null island
  );
}

// Remove duplicate coordinates that are very close together
function removeDuplicateCoordinates(records) {
  if (records.length === 0) return [];

  const unique = [records[0]];
  const threshold = 0.00001; // ~1 meter

  for (let i = 1; i < records.length; i++) {
    const current = records[i];
    const last = unique[unique.length - 1];

    const latDiff = Math.abs(current.latitude - last.latitude);
    const lonDiff = Math.abs(current.longitude - last.longitude);

    // Only add if significantly different from last point
    if (latDiff > threshold || lonDiff > threshold) {
      unique.push(current);
    }
  }

  return unique;
}

function extractTime(record) {
  if (!record) return null;

  // dji-log-parser-js format
  if (record.time) return new Date(record.time).toISOString();

  // Other formats
  return record.dateTime ||
    record.timestamp ||
    record['OSD.dateTime'] ||
    record.datetime ||
    record.Date ||
    record.offsetTime ||
    record['General.offsetTime'] ||
    record['OSD.time'] ||
    null;
}

function extractLatitude(record) {
  if (!record) return null;

  // dji-log-parser-js format
  if (record.latitude !== undefined) return record.latitude;
  if (record.gps && record.gps.latitude !== undefined) return record.gps.latitude;

  // Other formats
  const lat = record.lat ||
    record['OSD.latitude'] ||
    record.Latitude ||
    record['Home.latitude'] ||
    record['GPS.latitude'] ||
    null;

  return lat && !isNaN(lat) ? parseFloat(lat) : null;
}

function extractLongitude(record) {
  if (!record) return null;

  // dji-log-parser-js format
  if (record.longitude !== undefined) return record.longitude;
  if (record.gps && record.gps.longitude !== undefined) return record.gps.longitude;

  // Other formats
  const lon = record.lon ||
    record.lng ||
    record['OSD.longitude'] ||
    record.Longitude ||
    record['Home.longitude'] ||
    record['GPS.longitude'] ||
    null;

  return lon && !isNaN(lon) ? parseFloat(lon) : null;
}

function extractAltitude(record) {
  if (!record) return null;

  // dji-log-parser-js format
  if (record.altitude !== undefined) return record.altitude;
  if (record.gps && record.gps.altitude !== undefined) return record.gps.altitude;

  // Other formats
  const alt = record.alt ||
    record['OSD.altitude'] ||
    record.Altitude ||
    record['OSD.height'] ||
    record['GPS.altitude'] ||
    0;

  return alt && !isNaN(alt) ? parseFloat(alt) : 0;
}

function extractRelativeAltitude(record) {
  if (!record) return null;

  // dji-log-parser-js format
  if (record.relativeAltitude !== undefined) return record.relativeAltitude;
  if (record.barometer && record.barometer.altitude !== undefined) return record.barometer.altitude;

  // Other formats
  const relAlt = record.height ||
    record['OSD.height'] ||
    record.RelativeAltitude ||
    record['OSD.relativeHeight'] ||
    record['GPS.heightMSL'] ||
    0;

  return relAlt && !isNaN(relAlt) ? parseFloat(relAlt) : 0;
}

function calculateFlightDuration(parsedData) {
  if (!parsedData || parsedData.length < 2) return '0s';

  try {
    const startTime = extractTime(parsedData[0]);
    const endTime = extractTime(parsedData[parsedData.length - 1]);

    if (!startTime || !endTime) {
      return 'Unknown';
    }

    const start = new Date(startTime);
    const end = new Date(endTime);

    if (isNaN(start.getTime()) || isNaN(end.getTime())) {
      return 'Unknown';
    }

    const durationMs = end - start;

    const hours = Math.floor(durationMs / 3600000);
    const minutes = Math.floor((durationMs % 3600000) / 60000);
    const seconds = Math.floor((durationMs % 60000) / 1000);

    if (hours > 0) return `${hours}h ${minutes}m ${seconds}s`;
    if (minutes > 0) return `${minutes}m ${seconds}s`;
    return `${seconds}s`;
  } catch (err) {
    console.error('Duration calc error:', err);
    return 'Unknown';
  }
}

function calculateFlightStats(parsedData) {
  if (!parsedData || parsedData.length === 0) {
    return {
      maxAltitude: 0,
      maxSpeed: 0,
      totalDistance: 0,
      avgSpeed: 0,
    };
  }

  let maxAltitude = 0;
  let maxSpeed = 0;
  let totalDistance = 0;
  let speedSum = 0;
  let speedCount = 0;

  for (let i = 0; i < parsedData.length; i++) {
    const record = parsedData[i];

    // Max altitude
    const altitude = extractAltitude(record);
    if (altitude > maxAltitude) {
      maxAltitude = altitude;
    }

    // Speed tracking
    const speed = record.speed ||
      record.velocity ||
      record['OSD.speed'] ||
      record['OSD.hSpeed'] ||
      record['GPS.speed'] ||
      (record.gps && record.gps.speed) ||
      null;

    if (speed !== undefined && speed !== null && !isNaN(speed)) {
      const speedVal = parseFloat(speed);
      if (speedVal > maxSpeed) {
        maxSpeed = speedVal;
      }
      speedSum += speedVal;
      speedCount++;
    }

    // Calculate distance between consecutive points
    if (i > 0) {
      const lat = extractLatitude(record);
      const lon = extractLongitude(record);
      const prevLat = extractLatitude(parsedData[i - 1]);
      const prevLon = extractLongitude(parsedData[i - 1]);

      if (lat && lon && prevLat && prevLon) {
        totalDistance += calculateDistance(prevLat, prevLon, lat, lon);
      }
    }
  }

  return {
    maxAltitude: Math.round(maxAltitude * 100) / 100,
    maxSpeed: Math.round(maxSpeed * 100) / 100,
    totalDistance: Math.round(totalDistance * 100) / 100,
    avgSpeed: speedCount > 0 ? Math.round((speedSum / speedCount) * 100) / 100 : 0,
  };
}

function calculateDistance(lat1, lon1, lat2, lon2) {
  const R = 6371e3; // Earth's radius in meters
  const œÜ1 = lat1 * Math.PI / 180;
  const œÜ2 = lat2 * Math.PI / 180;
  const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
  const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

  const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
    Math.cos(œÜ1) * Math.cos(œÜ2) *
    Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

  return R * c; // Distance in meters
}

// ==================== EXISTING ENDPOINTS ====================

// Analyze drone images - Direct Python call
app.post('/api/analyze-drone', upload.array('images', 20), async (req, res) => {
  console.log('\n' + '='.repeat(60));
  console.log('üì• DRONE ANALYSIS REQUEST');
  console.log('='.repeat(60));

  try {
    if (!req.files || req.files.length === 0) {
      return res.status(400).json({ error: 'No files uploaded' });
    }

    console.log('üì∏ Processing', req.files.length, 'images');

    // Create a temporary Python script that uses vine.py functions directly
    const tempScript = path.join(__dirname, 'temp_drone_analysis.py');
    const scriptContent = `
import sys
import json
import os
sys.path.insert(0, '${__dirname.replace(/\\/g, '\\\\')}')

from vine import analyze_drone_images_rgb_only

# Get image paths from command line
image_paths = sys.argv[1:]

try:
    result = analyze_drone_images_rgb_only(image_paths)
    print(json.dumps(result))
except Exception as e:
    print(json.dumps({"error": str(e)}))
    sys.exit(1)
`;

    fs.writeFileSync(tempScript, scriptContent);

    const filePaths = req.files.map(f => path.join(uploadDir, f.filename));

    // Run Python script
    const result = await runPythonScript(tempScript, filePaths);

    // Cleanup
    fs.unlinkSync(tempScript);
    filePaths.forEach(f => {
      try { fs.unlinkSync(f); } catch (err) {}
    });

    console.log('‚úÖ Analysis complete');
    res.json({ success: true, data: result });

  } catch (error) {
    console.error('‚ùå ERROR:', error);
    res.status(500).json({ error: error.message });
  }
});

app.post('/api/analyze-orthophoto', upload.fields([
  { name: 'orthophoto', maxCount: 1 },
  { name: 'rows_geojson', maxCount: 1 }
]), async (req, res) => {
  console.log('\n' + '='.repeat(60));
  console.log('üì• ORTHOPHOTO ANALYSIS REQUEST');
  console.log('='.repeat(60));

  try {
    if (!req.files?.orthophoto) {
      return res.status(400).json({ error: 'No orthophoto uploaded' });
    }

    // GET METHOD FROM REQUEST BODY - WITH ENHANCED DEBUGGING
    const method = req.body.method || 'kmeans';
    console.log('üéØ Selected clustering method:', method);
    console.log('üìã Full req.body:', req.body);
    console.log('üìÇ Files received:', Object.keys(req.files));

    const orthophotoPath = path.join(uploadDir, req.files.orthophoto[0].filename);
    console.log('üì∏ Orthophoto:', orthophotoPath);

    let rowsPath = null;
    if (req.files?.rows_geojson) {
      rowsPath = path.join(uploadDir, req.files.rows_geojson[0].filename);
      console.log('üìç Rows GeoJSON:', rowsPath);
    }

    // Create temporary Python script with method parameter
    const tempScript = path.join(__dirname, 'temp_ortho_analysis.py');
    const scriptContent = `
import sys
import json
import os
sys.path.insert(0, '${__dirname.replace(/\\/g, '\\\\')}')

from vine import Config, analyze_orthophoto

# Update Config with uploaded files
Config.ORTHO_PATH = r'${orthophotoPath.replace(/\\/g, '\\\\')}'
${rowsPath ? `Config.ROWS_PATH = r'${rowsPath.replace(/\\/g, '\\\\')}'` : ''}

try:
    # Run the analysis WITH METHOD PARAMETER
    print("üîß Python: Calling analyze_orthophoto with method='${method}'", file=sys.stderr)
    result = analyze_orthophoto(method='${method}')
    
    if result is None:
        print(json.dumps({"error": "Analysis returned no results"}))
        sys.exit(1)
    
    print(f"üîß Python: Result method is '{result.get('method', 'MISSING')}'", file=sys.stderr)
    
    # Format output - FIXED: method is now correctly retrieved
    output = {
        'method': result.get('method', 'kmeans'),
        'detected_gaps': len(result.get('gaps', [])),
        'total_gap_area_m2': sum(g.get('area_sqm', 0) for g in result.get('gaps', [])),
        'rows_analyzed': result.get('total_rows', 0),
        'rows_with_gaps': len(result.get('row_summary', [])),
        'details': [{
            'filename': os.path.basename(Config.ORTHO_PATH),
            'gaps_detected': len(result.get('gaps', [])),
            'gap_area_m2': sum(g.get('area_sqm', 0) for g in result.get('gaps', [])),
            'row_details': result.get('row_summary', [])
        }]
    }
    
    print(json.dumps(output))
    
except Exception as e:
    import traceback
    print(json.dumps({
        "error": str(e),
        "traceback": traceback.format_exc()
    }))
    sys.exit(1)
`;

    fs.writeFileSync(tempScript, scriptContent);

    // Run Python script
    console.log('üêç Calling Python script with method:', method);
    const result = await runPythonScript(tempScript, []);

    console.log('üìä Python result received:');
    console.log('   - Method:', result.method);
    console.log('   - Gaps:', result.detected_gaps);
    console.log('   - Full result:', JSON.stringify(result, null, 2));

    // Cleanup
    fs.unlinkSync(tempScript);
    try { fs.unlinkSync(orthophotoPath); } catch (err) {}
    if (rowsPath) {
      try { fs.unlinkSync(rowsPath); } catch (err) {}
    }

    console.log('‚úÖ Analysis complete');
    console.log('üì§ Sending to frontend - method:', result.method);
    res.json({ success: true, data: result });

  } catch (error) {
    console.error('‚ùå ERROR:', error);
    res.status(500).json({ error: error.message });
  }
});
function runPythonScript(scriptPath, args) {
  return new Promise((resolve, reject) => {
    console.log('üêç Running Python:', scriptPath);

    const python = spawn('python3', [scriptPath, ...args]);

    let stdout = '';
    let stderr = '';

    python.stdout.on('data', (data) => {
      stdout += data.toString();
    });

    python.stderr.on('data', (data) => {
      stderr += data.toString();
      console.log('Python stderr:', data.toString());
    });

    python.on('close', (code) => {
      console.log('Python process exited with code:', code);

      if (code !== 0) {
        console.error('Python stderr:', stderr);
        reject(new Error(`Python script failed: ${stderr}`));
        return;
      }

      try {
        // Find the last JSON output (in case there's debug output before it)
        const lines = stdout.trim().split('\n');
        let jsonOutput = null;

        for (let i = lines.length - 1; i >= 0; i--) {
          try {
            jsonOutput = JSON.parse(lines[i]);
            break;
          } catch (e) {
            continue;
          }
        }

        if (!jsonOutput) {
          throw new Error('No valid JSON found in output');
        }

        if (jsonOutput.error) {
          reject(new Error(jsonOutput.error));
        } else {
          resolve(jsonOutput);
        }
      } catch (e) {
        console.error('Failed to parse output:', stdout);
        reject(new Error(`Failed to parse Python output: ${e.message}`));
      }
    });
  });
}

app.listen(PORT, '0.0.0.0', () => {
  console.log('\n' + '='.repeat(60));
  console.log('‚úÖ SERVER RUNNING');
  console.log('='.repeat(60));
  console.log(`üåê Local:    http://localhost:${PORT}`);
  console.log(`üåê Network:  http://0.0.0.0:${PORT}`);
  console.log('='.repeat(60));
  console.log('\nüí° Waiting for requests...\n');
});