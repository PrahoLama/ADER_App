const express = require('express');
const multer = require('multer');
const cors = require('cors');
const path = require('path');
const fs = require('fs');
const { spawn } = require('child_process');
const FormData = require('form-data');
const axios = require('axios');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 5000;

// Enhanced logging middleware
app.use((req, res, next) => {
  console.log(`[${new Date().toISOString()}] ${req.method} ${req.url}`);
  next();
});

// CORS configuration
app.use(cors({
  origin: '*',
  credentials: true,
  methods: ['GET', 'POST', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization']
}));

app.use(express.json());

// Create uploads directory
const uploadDir = path.join(__dirname, 'uploads');
if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir, { recursive: true });
  console.log('‚úÖ Created uploads directory:', uploadDir);
}

// Configure multer
const storage = multer.diskStorage({
  destination: (req, file, cb) => cb(null, uploadDir),
  filename: (req, file, cb) => {
    const filename = Date.now() + path.extname(file.originalname);
    cb(null, filename);
  }
});

const upload = multer({
  storage,
  limits: { fileSize: 500 * 1024 * 1024 }
});

// Health check
app.get('/api/health', (req, res) => {
  console.log('‚úÖ Health check received');
  res.json({ status: 'Backend running', timestamp: new Date() });
});

// ==================== ENHANCED DJI LOG PARSER WITH DEEP DEBUGGING ====================

// ==================== DJI LOG PARSER WITH dji-log BINARY ====================

app.post('/api/parse-dji-log', upload.single('logFile'), async (req, res) => {
  console.log('\n' + '='.repeat(60));
  console.log('üöÅ DJI LOG PARSING REQUEST - USING dji-log BINARY');
  console.log('='.repeat(60));

  const djiLogBinary = path.join(__dirname, 'dji-log'); // Path to dji-log binary
  let logFilePath = null;
  let csvOutputPath = null;

  try {
    if (!req.file) {
      return res.status(400).json({ error: 'No log file uploaded' });
    }

    logFilePath = path.join(uploadDir, req.file.filename);
    csvOutputPath = path.join(uploadDir, `flight_data_${Date.now()}.csv`);

    console.log('üìÑ Log file:', logFilePath);
    console.log('üì¶ File size:', req.file.size, 'bytes');
    console.log('üìù Output CSV:', csvOutputPath);

    // Check if dji-log binary exists
    if (!fs.existsSync(djiLogBinary)) {
      throw new Error('dji-log binary not found. Please download it from https://github.com/lvauvillier/dji-log-parser/releases');
    }

    // ============================================================
    // STEP 1: Run dji-log command to convert TXT to CSV
    // ============================================================
    console.log('\nüîß Running dji-log command...');

    const apiKey = process.env.DJI_API_KEY || '6a1613c4a95bea88c227b4b760e528e';

    await new Promise((resolve, reject) => {
      const djiLogProcess = spawn(djiLogBinary, [
        '--api-key', apiKey,
        logFilePath,
        '--csv', csvOutputPath
      ]);

      let stdout = '';
      let stderr = '';

      djiLogProcess.stdout.on('data', (data) => {
        stdout += data.toString();
        console.log('dji-log stdout:', data.toString());
      });

      djiLogProcess.stderr.on('data', (data) => {
        stderr += data.toString();
        console.error('dji-log stderr:', data.toString());
      });

      djiLogProcess.on('close', (code) => {
        console.log('dji-log process exited with code:', code);

        if (code !== 0) {
          reject(new Error(`dji-log failed with code ${code}: ${stderr}`));
        } else {
          console.log('‚úÖ CSV file generated successfully');
          resolve();
        }
      });

      djiLogProcess.on('error', (error) => {
        reject(new Error(`Failed to run dji-log: ${error.message}`));
      });
    });

    // ============================================================
    // STEP 2: Parse the generated CSV file
    // ============================================================
    console.log('\nüìä Parsing generated CSV file...');

    if (!fs.existsSync(csvOutputPath)) {
      throw new Error('CSV file was not generated by dji-log');
    }

    const csvContent = fs.readFileSync(csvOutputPath, 'utf8');
    const lines = csvContent.split('\n').filter(line => line.trim());

    console.log(`üìã Total lines in CSV: ${lines.length}`);

    if (lines.length < 2) {
      throw new Error('CSV file is empty or invalid');
    }

    // Parse CSV header
    const header = lines[0].split(',').map(h => h.trim().replace(/^"|"$/g, ''));
    console.log(`üìã CSV Headers (${header.length} columns):`, header.slice(0, 10));

    // Find key column indices
    const keyColumns = {
      datetime: header.findIndex(h => h.toLowerCase().includes('datetime') || h.toLowerCase().includes('time')),
      latitude: header.findIndex(h => h.toLowerCase().includes('latitude') || h === 'OSD.latitude'),
      longitude: header.findIndex(h => h.toLowerCase().includes('longitude') || h === 'OSD.longitude'),
      altitude: header.findIndex(h => h.toLowerCase().includes('altitude') || h === 'OSD.altitude'),
      height: header.findIndex(h => h.toLowerCase().includes('height') || h === 'OSD.height'),
      speed: header.findIndex(h => h.toLowerCase().includes('speed')),
      battery: header.findIndex(h => h.toLowerCase().includes('battery') && h.toLowerCase().includes('level')),
    };

    console.log('üîç Key column indices:', keyColumns);

    // Parse data rows
    const parsedData = [];
    for (let i = 1; i < lines.length; i++) {
      const line = lines[i];
      if (!line.trim()) continue;

      // Enhanced CSV parsing (handles quoted values)
      const values = [];
      let current = '';
      let inQuotes = false;

      for (let j = 0; j < line.length; j++) {
        const char = line[j];
        if (char === '"') {
          inQuotes = !inQuotes;
        } else if (char === ',' && !inQuotes) {
          values.push(current.trim().replace(/^"|"$/g, ''));
          current = '';
        } else {
          current += char;
        }
      }
      values.push(current.trim().replace(/^"|"$/g, ''));

      // Build row object
      const row = {};
      for (let idx = 0; idx < Math.min(values.length, header.length); idx++) {
        let value = values[idx];
        // Try to parse as number
        if (value && value !== '' && !isNaN(value)) {
          value = parseFloat(value);
        }
        row[header[idx]] = value;
      }

      // Only add rows with valid GPS data
      const lat = keyColumns.latitude >= 0 ? row[header[keyColumns.latitude]] : null;
      const lon = keyColumns.longitude >= 0 ? row[header[keyColumns.longitude]] : null;

      if (lat && lon && !isNaN(lat) && !isNaN(lon)) {
        parsedData.push(row);
      }
    }

    console.log(`‚úÖ Parsed ${parsedData.length} valid GPS records`);

    if (parsedData.length === 0) {
      throw new Error('No valid GPS data found in the log file');
    }

    // ============================================================
    // STEP 3: Extract flight information for dashboard
    // ============================================================
    console.log('\nüìä Extracting flight information...');

    const flightPath = parsedData.map(record => {
      const datetime = keyColumns.datetime >= 0 ? record[header[keyColumns.datetime]] : null;
      const latitude = keyColumns.latitude >= 0 ? parseFloat(record[header[keyColumns.latitude]]) : null;
      const longitude = keyColumns.longitude >= 0 ? parseFloat(record[header[keyColumns.longitude]]) : null;
      const altitude = keyColumns.altitude >= 0 ? parseFloat(record[header[keyColumns.altitude]]) || 0 : 0;
      const height = keyColumns.height >= 0 ? parseFloat(record[header[keyColumns.height]]) || 0 : 0;

      return {
        timestamp: datetime,
        latitude: latitude,
        longitude: longitude,
        altitude: altitude,
        relativeAltitude: height,
      };
    }).filter(point => point.latitude && point.longitude);

    // Calculate statistics
    let maxAltitude = 0;
    let maxSpeed = 0;
    let totalDistance = 0;
    let maxBattery = 0;
    let minBattery = 100;

    for (let i = 0; i < parsedData.length; i++) {
      const record = parsedData[i];

      // Altitude
      const altitude = keyColumns.altitude >= 0 ? parseFloat(record[header[keyColumns.altitude]]) || 0 : 0;
      if (altitude > maxAltitude) maxAltitude = altitude;

      // Speed
      const speed = keyColumns.speed >= 0 ? parseFloat(record[header[keyColumns.speed]]) || 0 : 0;
      if (speed > maxSpeed) maxSpeed = speed;

      // Battery
      const battery = keyColumns.battery >= 0 ? parseFloat(record[header[keyColumns.battery]]) || 0 : 0;
      if (battery > maxBattery) maxBattery = battery;
      if (battery < minBattery && battery > 0) minBattery = battery;

      // Distance between consecutive points
      if (i > 0) {
        const lat = keyColumns.latitude >= 0 ? parseFloat(record[header[keyColumns.latitude]]) : null;
        const lon = keyColumns.longitude >= 0 ? parseFloat(record[header[keyColumns.longitude]]) : null;
        const prevLat = keyColumns.latitude >= 0 ? parseFloat(parsedData[i - 1][header[keyColumns.latitude]]) : null;
        const prevLon = keyColumns.longitude >= 0 ? parseFloat(parsedData[i - 1][header[keyColumns.longitude]]) : null;

        if (lat && lon && prevLat && prevLon) {
          totalDistance += calculateDistance(prevLat, prevLon, lat, lon);
        }
      }
    }

    // Calculate duration
    const startTime = keyColumns.datetime >= 0 ? parsedData[0][header[keyColumns.datetime]] : null;
    const endTime = keyColumns.datetime >= 0 ? parsedData[parsedData.length - 1][header[keyColumns.datetime]] : null;
    let duration = 'Unknown';

    if (startTime && endTime) {
      try {
        const start = new Date(startTime);
        const end = new Date(endTime);
        const durationMs = end - start;

        const hours = Math.floor(durationMs / 3600000);
        const minutes = Math.floor((durationMs % 3600000) / 60000);
        const seconds = Math.floor((durationMs % 60000) / 1000);

        if (hours > 0) duration = `${hours}h ${minutes}m ${seconds}s`;
        else if (minutes > 0) duration = `${minutes}m ${seconds}s`;
        else duration = `${seconds}s`;
      } catch (e) {
        console.error('Duration calculation error:', e);
      }
    }

    const flightInfo = {
      fileName: req.file.originalname,
      fileSize: req.file.size,
      parsedAt: new Date().toISOString(),
      parsingMethod: 'dji-log-binary',

      summary: {
        totalRecords: parsedData.length,
        duration: duration,
        startTime: startTime,
        endTime: endTime,
      },

      flightPath: flightPath,

      statistics: {
        maxAltitude: Math.round(maxAltitude * 100) / 100,
        maxSpeed: Math.round(maxSpeed * 100) / 100,
        totalDistance: Math.round(totalDistance * 100) / 100,
        avgSpeed: parsedData.length > 0 ? Math.round((totalDistance / (parsedData.length * 0.2)) * 100) / 100 : 0,
        batteryStart: maxBattery,
        batteryEnd: minBattery,
      },

      rawDataSample: parsedData.slice(0, 100),
      hasMoreData: parsedData.length > 100,
    };

    console.log('\nüìä FLIGHT SUMMARY:');
    console.log('  Records:', flightInfo.summary.totalRecords);
    console.log('  Duration:', flightInfo.summary.duration);
    console.log('  GPS points:', flightInfo.flightPath.length);
    console.log('  Max altitude:', flightInfo.statistics.maxAltitude, 'm');
    console.log('  Max speed:', flightInfo.statistics.maxSpeed, 'm/s');
    console.log('  Total distance:', flightInfo.statistics.totalDistance, 'm');

    // ============================================================
    // STEP 4: Cleanup temporary files
    // ============================================================
    console.log('\nüßπ Cleaning up temporary files...');
    try {
      if (logFilePath && fs.existsSync(logFilePath)) {
        fs.unlinkSync(logFilePath);
        console.log('‚úÖ Deleted log file');
      }
      if (csvOutputPath && fs.existsSync(csvOutputPath)) {
        fs.unlinkSync(csvOutputPath);
        console.log('‚úÖ Deleted CSV file');
      }
    } catch (cleanupErr) {
      console.error('‚ö†Ô∏è Cleanup error:', cleanupErr.message);
    }

    // ============================================================
    // STEP 5: Return results to frontend
    // ============================================================
    res.json({
      success: true,
      data: flightInfo
    });

  } catch (error) {
    console.error('\n' + '='.repeat(60));
    console.error('‚ùå FATAL ERROR');
    console.error('='.repeat(60));
    console.error('Error:', error.message);
    console.error('Stack:', error.stack);

    // Cleanup on error
    try {
      if (logFilePath && fs.existsSync(logFilePath)) {
        fs.unlinkSync(logFilePath);
      }
      if (csvOutputPath && fs.existsSync(csvOutputPath)) {
        fs.unlinkSync(csvOutputPath);
      }
    } catch (cleanupErr) {
      console.error('Cleanup error:', cleanupErr.message);
    }

    res.status(500).json({
      error: 'Failed to parse DJI log file',
      details: error.message,
      hint: 'Make sure dji-log binary is in the backend folder'
    });
  }
});

// Helper function to calculate distance between GPS coordinates
function calculateDistance(lat1, lon1, lat2, lon2) {
  const R = 6371e3; // Earth's radius in meters
  const œÜ1 = lat1 * Math.PI / 180;
  const œÜ2 = lat2 * Math.PI / 180;
  const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
  const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

  const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
    Math.cos(œÜ1) * Math.cos(œÜ2) *
    Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

  return R * c; // Distance in meters
}
// ==================== HELPER FUNCTIONS ====================

// Enhanced DJI Binary Log Format Parser
async function parseDJIBinaryLog(fileBuffer) {
  try {
    const header = fileBuffer.slice(0, 4).toString('hex');
    console.log('üîç Binary header:', header);
    console.log('üì¶ File size:', fileBuffer.length, 'bytes');

    const records = [];

    // DJI Format Detection
    const isDJIFormat = header.startsWith('29') || header.startsWith('55') || header.startsWith('66');

    if (!isDJIFormat) {
      throw new Error(`Not a recognized DJI binary format (header: ${header})`);
    }

    console.log('‚úÖ Detected DJI binary format');

    // Parse DJI Record Structure
    console.log('üîç Parsing DJI record structure...');

    let offset = 0;
    let recordCount = 0;

    while (offset < fileBuffer.length - 100) {
      try {
        // Look for record markers (0x29 is common DJI record marker)
        if (fileBuffer[offset] === 0x29 && offset + 60 < fileBuffer.length) {

          // Read potential record header
          const recordType = fileBuffer[offset + 1];
          const recordLength = fileBuffer.readUInt16LE(offset + 2);

          // Validate record length
          if (recordLength > 0 && recordLength < 1000 && offset + recordLength < fileBuffer.length) {

            // Try to extract GPS data from various offset positions
            const gpsOffsets = [8, 12, 16, 20, 24, 28, 32, 36, 40];

            for (const gpsOffset of gpsOffsets) {
              if (offset + gpsOffset + 16 <= fileBuffer.length) {

                // Try reading as double (8 bytes each for lat/lon)
                const lat1 = readSafeDouble(fileBuffer, offset + gpsOffset);
                const lon1 = readSafeDouble(fileBuffer, offset + gpsOffset + 8);

                if (isValidCoordinate(lat1, lon1)) {
                  const altitude = readSafeFloat(fileBuffer, offset + gpsOffset + 16) || 0;

                  // Try to find timestamp
                  let timestamp = null;
                  for (let ts = offset; ts < offset + 40 && ts + 4 < fileBuffer.length; ts += 4) {
                    const possibleTime = fileBuffer.readUInt32LE(ts);
                    if (possibleTime > 1420070400 && possibleTime < 1893456000) {
                      timestamp = new Date(possibleTime * 1000).toISOString();
                      break;
                    }
                  }

                  records.push({
                    latitude: lat1,
                    longitude: lon1,
                    altitude: altitude,
                    relativeAltitude: altitude,
                    timestamp: timestamp || new Date().toISOString()
                  });

                  recordCount++;
                  break;
                }

                // Try reading as float (4 bytes each for lat/lon)
                const lat2 = readSafeFloat(fileBuffer, offset + gpsOffset);
                const lon2 = readSafeFloat(fileBuffer, offset + gpsOffset + 4);

                if (isValidCoordinate(lat2, lon2)) {
                  const altitude = readSafeFloat(fileBuffer, offset + gpsOffset + 8) || 0;

                  records.push({
                    latitude: lat2,
                    longitude: lon2,
                    altitude: altitude,
                    relativeAltitude: altitude,
                    timestamp: new Date().toISOString()
                  });

                  recordCount++;
                  break;
                }
              }
            }

            offset += recordLength;
          } else {
            offset++;
          }
        } else {
          offset++;
        }
      } catch (e) {
        offset++;
      }
    }

    // Remove duplicates
    const uniqueRecords = removeDuplicateCoordinates(records);

    console.log('üìä Total GPS points found:', uniqueRecords.length);

    if (uniqueRecords.length >= 5) {
      console.log('‚úÖ Successfully extracted GPS data from binary format');
      return uniqueRecords;
    } else {
      throw new Error(
        `Not enough valid GPS data found (found ${uniqueRecords.length} points, need at least 5).\n\n` +
        `This appears to be an encrypted or proprietary DJI format.\n\n` +
        `üìã Recommended solutions:\n` +
        `1. Install dji-log-parser-js: npm install dji-log-parser-js\n` +
        `2. Get DJI API key for v13+ encrypted logs from https://developer.dji.com/\n` +
        `3. Use DJI Flight Log Viewer (https://www.phantomhelp.com/logviewer/upload/)\n` +
        `4. Use Airdata UAV (https://app.airdata.com/) for professional parsing`
      );
    }
  } catch (error) {
    throw error;
  }
}

// Helper function to safely read doubles
function readSafeDouble(buffer, offset) {
  if (offset + 8 > buffer.length) return null;
  try {
    const value = buffer.readDoubleLE(offset);
    return (isNaN(value) || !isFinite(value)) ? null : value;
  } catch (e) {
    return null;
  }
}

// Helper function to safely read floats
function readSafeFloat(buffer, offset) {
  if (offset + 4 > buffer.length) return null;
  try {
    const value = buffer.readFloatLE(offset);
    return (isNaN(value) || !isFinite(value)) ? null : value;
  } catch (e) {
    return null;
  }
}

// Validate GPS coordinates
function isValidCoordinate(lat, lon) {
  return (
    typeof lat === 'number' &&
    typeof lon === 'number' &&
    !isNaN(lat) &&
    !isNaN(lon) &&
    isFinite(lat) &&
    isFinite(lon) &&
    lat >= -90 &&
    lat <= 90 &&
    lon >= -180 &&
    lon <= 180 &&
    (Math.abs(lat) > 0.001 || Math.abs(lon) > 0.001) // Not null island
  );
}

// Remove duplicate coordinates that are very close together
function removeDuplicateCoordinates(records) {
  if (records.length === 0) return [];

  const unique = [records[0]];
  const threshold = 0.00001; // ~1 meter

  for (let i = 1; i < records.length; i++) {
    const current = records[i];
    const last = unique[unique.length - 1];

    const latDiff = Math.abs(current.latitude - last.latitude);
    const lonDiff = Math.abs(current.longitude - last.longitude);

    // Only add if significantly different from last point
    if (latDiff > threshold || lonDiff > threshold) {
      unique.push(current);
    }
  }

  return unique;
}

function extractTime(record) {
  if (!record) return null;

  // dji-log-parser-js format
  if (record.time) return new Date(record.time).toISOString();

  // Other formats
  return record.dateTime ||
    record.timestamp ||
    record['OSD.dateTime'] ||
    record.datetime ||
    record.Date ||
    record.offsetTime ||
    record['General.offsetTime'] ||
    record['OSD.time'] ||
    null;
}

function extractLatitude(record) {
  if (!record) return null;

  // dji-log-parser-js format
  if (record.latitude !== undefined) return record.latitude;
  if (record.gps && record.gps.latitude !== undefined) return record.gps.latitude;

  // Other formats
  const lat = record.lat ||
    record['OSD.latitude'] ||
    record.Latitude ||
    record['Home.latitude'] ||
    record['GPS.latitude'] ||
    null;

  return lat && !isNaN(lat) ? parseFloat(lat) : null;
}

function extractLongitude(record) {
  if (!record) return null;

  // dji-log-parser-js format
  if (record.longitude !== undefined) return record.longitude;
  if (record.gps && record.gps.longitude !== undefined) return record.gps.longitude;

  // Other formats
  const lon = record.lon ||
    record.lng ||
    record['OSD.longitude'] ||
    record.Longitude ||
    record['Home.longitude'] ||
    record['GPS.longitude'] ||
    null;

  return lon && !isNaN(lon) ? parseFloat(lon) : null;
}

function extractAltitude(record) {
  if (!record) return null;

  // dji-log-parser-js format
  if (record.altitude !== undefined) return record.altitude;
  if (record.gps && record.gps.altitude !== undefined) return record.gps.altitude;

  // Other formats
  const alt = record.alt ||
    record['OSD.altitude'] ||
    record.Altitude ||
    record['OSD.height'] ||
    record['GPS.altitude'] ||
    0;

  return alt && !isNaN(alt) ? parseFloat(alt) : 0;
}

function extractRelativeAltitude(record) {
  if (!record) return null;

  // dji-log-parser-js format
  if (record.relativeAltitude !== undefined) return record.relativeAltitude;
  if (record.barometer && record.barometer.altitude !== undefined) return record.barometer.altitude;

  // Other formats
  const relAlt = record.height ||
    record['OSD.height'] ||
    record.RelativeAltitude ||
    record['OSD.relativeHeight'] ||
    record['GPS.heightMSL'] ||
    0;

  return relAlt && !isNaN(relAlt) ? parseFloat(relAlt) : 0;
}

function calculateFlightDuration(parsedData) {
  if (!parsedData || parsedData.length < 2) return '0s';

  try {
    const startTime = extractTime(parsedData[0]);
    const endTime = extractTime(parsedData[parsedData.length - 1]);

    if (!startTime || !endTime) {
      return 'Unknown';
    }

    const start = new Date(startTime);
    const end = new Date(endTime);

    if (isNaN(start.getTime()) || isNaN(end.getTime())) {
      return 'Unknown';
    }

    const durationMs = end - start;

    const hours = Math.floor(durationMs / 3600000);
    const minutes = Math.floor((durationMs % 3600000) / 60000);
    const seconds = Math.floor((durationMs % 60000) / 1000);

    if (hours > 0) return `${hours}h ${minutes}m ${seconds}s`;
    if (minutes > 0) return `${minutes}m ${seconds}s`;
    return `${seconds}s`;
  } catch (err) {
    console.error('Duration calc error:', err);
    return 'Unknown';
  }
}

function calculateFlightStats(parsedData) {
  if (!parsedData || parsedData.length === 0) {
    return {
      maxAltitude: 0,
      maxSpeed: 0,
      totalDistance: 0,
      avgSpeed: 0,
    };
  }

  let maxAltitude = 0;
  let maxSpeed = 0;
  let totalDistance = 0;
  let speedSum = 0;
  let speedCount = 0;

  for (let i = 0; i < parsedData.length; i++) {
    const record = parsedData[i];

    // Max altitude
    const altitude = extractAltitude(record);
    if (altitude > maxAltitude) {
      maxAltitude = altitude;
    }

    // Speed tracking
    const speed = record.speed ||
      record.velocity ||
      record['OSD.speed'] ||
      record['OSD.hSpeed'] ||
      record['GPS.speed'] ||
      (record.gps && record.gps.speed) ||
      null;

    if (speed !== undefined && speed !== null && !isNaN(speed)) {
      const speedVal = parseFloat(speed);
      if (speedVal > maxSpeed) {
        maxSpeed = speedVal;
      }
      speedSum += speedVal;
      speedCount++;
    }

    // Calculate distance between consecutive points
    if (i > 0) {
      const lat = extractLatitude(record);
      const lon = extractLongitude(record);
      const prevLat = extractLatitude(parsedData[i - 1]);
      const prevLon = extractLongitude(parsedData[i - 1]);

      if (lat && lon && prevLat && prevLon) {
        totalDistance += calculateDistance(prevLat, prevLon, lat, lon);
      }
    }
  }

  return {
    maxAltitude: Math.round(maxAltitude * 100) / 100,
    maxSpeed: Math.round(maxSpeed * 100) / 100,
    totalDistance: Math.round(totalDistance * 100) / 100,
    avgSpeed: speedCount > 0 ? Math.round((speedSum / speedCount) * 100) / 100 : 0,
  };
}

function calculateDistance(lat1, lon1, lat2, lon2) {
  const R = 6371e3; // Earth's radius in meters
  const œÜ1 = lat1 * Math.PI / 180;
  const œÜ2 = lat2 * Math.PI / 180;
  const ŒîœÜ = (lat2 - lat1) * Math.PI / 180;
  const ŒîŒª = (lon2 - lon1) * Math.PI / 180;

  const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
    Math.cos(œÜ1) * Math.cos(œÜ2) *
    Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

  return R * c; // Distance in meters
}

// ==================== EXISTING ENDPOINTS ====================

// Analyze drone images - Direct Python call
app.post('/api/analyze-drone', upload.array('images', 20), async (req, res) => {
  console.log('\n' + '='.repeat(60));
  console.log('üì• DRONE ANALYSIS REQUEST');
  console.log('='.repeat(60));

  try {
    if (!req.files || req.files.length === 0) {
      return res.status(400).json({ error: 'No files uploaded' });
    }

    console.log('üì∏ Processing', req.files.length, 'images');

    // Create a temporary Python script that uses vine.py functions directly
    const tempScript = path.join(__dirname, 'temp_drone_analysis.py');
    const scriptContent = `
import sys
import json
import os
sys.path.insert(0, '${__dirname.replace(/\\/g, '\\\\')}')

from vine import analyze_drone_images_rgb_only

# Get image paths from command line
image_paths = sys.argv[1:]

try:
    result = analyze_drone_images_rgb_only(image_paths)
    print(json.dumps(result))
except Exception as e:
    print(json.dumps({"error": str(e)}))
    sys.exit(1)
`;

    fs.writeFileSync(tempScript, scriptContent);

    const filePaths = req.files.map(f => path.join(uploadDir, f.filename));

    // Run Python script
    const result = await runPythonScript(tempScript, filePaths);

    // Cleanup
    fs.unlinkSync(tempScript);
    filePaths.forEach(f => {
      try { fs.unlinkSync(f); } catch (err) {}
    });

    console.log('‚úÖ Analysis complete');
    res.json({ success: true, data: result });

  } catch (error) {
    console.error('‚ùå ERROR:', error);
    res.status(500).json({ error: error.message });
  }
});

// Analyze orthophoto - Direct Python call
app.post('/api/analyze-orthophoto', upload.fields([
  { name: 'orthophoto', maxCount: 1 },
  { name: 'rows_geojson', maxCount: 1 }
]), async (req, res) => {
  console.log('\n' + '='.repeat(60));
  console.log('üì• ORTHOPHOTO ANALYSIS REQUEST');
  console.log('='.repeat(60));

  try {
    if (!req.files?.orthophoto) {
      return res.status(400).json({ error: 'No orthophoto uploaded' });
    }

    const orthophotoPath = path.join(uploadDir, req.files.orthophoto[0].filename);
    console.log('üì∏ Orthophoto:', orthophotoPath);

    let rowsPath = null;
    if (req.files?.rows_geojson) {
      rowsPath = path.join(uploadDir, req.files.rows_geojson[0].filename);
      console.log('üìç Rows GeoJSON:', rowsPath);
    }

    // Create temporary Python script that modifies vine.py Config and runs analysis
    const tempScript = path.join(__dirname, 'temp_ortho_analysis.py');
    const scriptContent = `
import sys
import json
import os
sys.path.insert(0, '${__dirname.replace(/\\/g, '\\\\')}')

from vine import Config, analyze_orthophoto

# Update Config with uploaded files
Config.ORTHO_PATH = r'${orthophotoPath.replace(/\\/g, '\\\\')}'
${rowsPath ? `Config.ROWS_PATH = r'${rowsPath.replace(/\\/g, '\\\\')}'` : ''}

try:
    # Run the analysis
    result = analyze_orthophoto()
    
    if result is None:
        print(json.dumps({"error": "Analysis returned no results"}))
        sys.exit(1)
    
    # Format output
    output = {
        'detected_gaps': len(result.get('gaps', [])),
        'total_gap_area_m2': sum(g.get('area_sqm', 0) for g in result.get('gaps', [])),
        'rows_analyzed': result.get('total_rows', 0),
        'rows_with_gaps': len(result.get('row_summary', [])),
        'details': [{
            'filename': os.path.basename(Config.ORTHO_PATH),
            'gaps_detected': len(result.get('gaps', [])),
            'gap_area_m2': sum(g.get('area_sqm', 0) for g in result.get('gaps', [])),
            'row_details': result.get('row_summary', [])
        }]
    }
    
    print(json.dumps(output))
    
except Exception as e:
    import traceback
    print(json.dumps({
        "error": str(e),
        "traceback": traceback.format_exc()
    }))
    sys.exit(1)
`;

    fs.writeFileSync(tempScript, scriptContent);

    // Run Python script
    const result = await runPythonScript(tempScript, []);

    // Cleanup
    fs.unlinkSync(tempScript);
    try { fs.unlinkSync(orthophotoPath); } catch (err) {}
    if (rowsPath) {
      try { fs.unlinkSync(rowsPath); } catch (err) {}
    }

    console.log('‚úÖ Analysis complete');
    res.json({ success: true, data: result });

  } catch (error) {
    console.error('‚ùå ERROR:', error);
    res.status(500).json({ error: error.message });
  }
});

function runPythonScript(scriptPath, args) {
  return new Promise((resolve, reject) => {
    console.log('üêç Running Python:', scriptPath);

    const python = spawn('python3', [scriptPath, ...args]);

    let stdout = '';
    let stderr = '';

    python.stdout.on('data', (data) => {
      stdout += data.toString();
    });

    python.stderr.on('data', (data) => {
      stderr += data.toString();
      console.log('Python stderr:', data.toString());
    });

    python.on('close', (code) => {
      console.log('Python process exited with code:', code);

      if (code !== 0) {
        console.error('Python stderr:', stderr);
        reject(new Error(`Python script failed: ${stderr}`));
        return;
      }

      try {
        // Find the last JSON output (in case there's debug output before it)
        const lines = stdout.trim().split('\n');
        let jsonOutput = null;

        for (let i = lines.length - 1; i >= 0; i--) {
          try {
            jsonOutput = JSON.parse(lines[i]);
            break;
          } catch (e) {
            continue;
          }
        }

        if (!jsonOutput) {
          throw new Error('No valid JSON found in output');
        }

        if (jsonOutput.error) {
          reject(new Error(jsonOutput.error));
        } else {
          resolve(jsonOutput);
        }
      } catch (e) {
        console.error('Failed to parse output:', stdout);
        reject(new Error(`Failed to parse Python output: ${e.message}`));
      }
    });
  });
}

app.listen(PORT, '0.0.0.0', () => {
  console.log('\n' + '='.repeat(60));
  console.log('‚úÖ SERVER RUNNING');
  console.log('='.repeat(60));
  console.log(`üåê Local:    http://localhost:${PORT}`);
  console.log(`üåê Network:  http://0.0.0.0:${PORT}`);
  console.log('='.repeat(60));
  console.log('\nüí° Waiting for requests...\n');
});